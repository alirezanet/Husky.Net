import{r as n,o as r,c as a,b as e,a as s,F as i,e as o}from"./app.b09da964.js";import{_ as l}from"./plugin-vue_export-helper.21dcd24c.js";var d="/Husky.Net/assets/workflow.290a20c9.jpg";const c={},h=e("h1",{id:"introduction",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#introduction","aria-hidden":"true"},"#"),o(" Introduction")],-1),u=e("p",null,[e("img",{src:d,alt:"Husky.Net WorkFlow"})],-1),_=e("blockquote",null,[e("p",null,"Husky improves your commits and more \u{1F436} woof!"),e("p",null,"Run linters against staged git files and don't let \u{1F4A9} slip into your code base!")],-1),m=o("These two quotes from "),p={href:"https://github.com/typicode/husky",target:"_blank",rel:"noopener noreferrer"},f=o("husky"),y=o(" and "),k={href:"https://github.com/okonet/lint-staged",target:"_blank",rel:"noopener noreferrer"},g=o("lint-staged"),b=o(" JS tools inspired me to create Husky.Net for dotnet developers. it provides a simple native way to do both also has a lot of other cool features, You can use it to lint your commit messages, run tests, lint/format code, etc... when you commit or push. \u{1F680}\u{1F680}"),w=e("h2",{id:"features",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#features","aria-hidden":"true"},"#"),o(" Features")],-1),v=e("li",null,[o("\u{1F525} It brings the "),e("strong",null,"dev-dependency"),o(" concept to the .NET world!")],-1),x=e("li",null,"\u{1F525} Supports all Git & gitflow hooks",-1),N=e("li",null,"\u{1F525} Internal task runner!",-1),S=e("li",null,"Multiple file states (staged, last-commit, git-files, etc...)",-1),H=e("li",null,"CSharp scripts (csx)",-1),I=e("li",null,"Supports macOS, Linux and Windows",-1),C=e("li",null,"Powered by modern new Git feature (core.hooksPath)",-1),T=e("li",null,"User-define variables",-1),G=o("Compatible with "),j={href:"https://github.com/dotnet/format",target:"_blank",rel:"noopener noreferrer"},L=o("dotnet-format"),W=o(", "),E={href:"https://csharpier.com/",target:"_blank",rel:"noopener noreferrer"},F=o("CSharpier"),A=o(", "),B={href:"https://www.jetbrains.com/help/resharper/ReSharper_Command_Line_Tools.html",target:"_blank",rel:"noopener noreferrer"},R=o("ReSharper command line tools"),U=o(" and other formatting tools"),V=e("li",null,"User-friendly messages",-1),q=e("li",null,"Git GUIs",-1),D=e("li",null,"Custom directories",-1),M=e("li",null,"Monorepo",-1),O=e("p",null,[o("-"),e("em",null,"A lot of features are coming soon, stay tuned! \u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F\u{1F440}")],-1),P=e("h2",{id:"why-use-hooks-and-husky-net",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#why-use-hooks-and-husky-net","aria-hidden":"true"},"#"),o(" Why use Hooks and Husky.Net?")],-1),Y=e("p",null,"We, as developers, love platforms like GitHub, GitLab, Atlassian, Azure DevOps etc., as our managed git system and collaboration platform. We also love clean code and keep inventing new linters and rules to enforce it. In my opinion, every commit should allow the codebase to deploy to production. There is nothing worse than commits like \u201Cfixed style errors\u201D or \u201Cfixed build\u201D. These are often small mistakes you want to know as early as possible in your development cycle. You don\u2019t want to break the build for the next developer because he pulled your \u2018mistake\u2019 or waste precious build minutes of your CI server. Say you have asked your teammate to review your code; in the meantime, the build server rejects your code. That means you have to go back and fix this, and your teammate has to come back and possibly review again after the changes (i.e., approvals reset on new commit). Doing so would waste a lot of time and effort.",-1),z=e("p",null,"Husky.Net offers a very simple way to start using git hooks or running certain tasks, write and run custom scripts and more ...",-1);function J(K,Q){const t=n("ExternalLinkIcon");return r(),a(i,null,[h,u,_,e("p",null,[m,e("a",p,[f,s(t)]),y,e("a",k,[g,s(t)]),b]),w,e("ul",null,[v,x,N,S,H,I,C,T,e("li",null,[G,e("a",j,[L,s(t)]),W,e("a",E,[F,s(t)]),A,e("a",B,[R,s(t)]),U]),V,q,D,M]),O,P,Y,z],64)}var $=l(c,[["render",J]]);export{$ as default};
